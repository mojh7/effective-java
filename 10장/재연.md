## 아이템 69: 예외는 진짜 예외 상황에서만 사용하라

```java
try{
	int i = 0;
	while(true) range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e){
}
```
- 직관적이지 않음

```java
for (Mountain m : range) m.climb();
```
- 이렇게 쓰면 더 직관적임
- 예외를 써서 루프를 종료한 이유 > 잘못된 추론을 근거로 성능을 높여보려 한 것

**[하지만 이것이 잘 못된 추론이라는 3가지 이유]**

1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약함
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한
3. 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않음 > JVM이 알아서 최적화를 없앰

- 따라서 예외를 사용한 쪽이 표준 관용구보다 느림
- 예외는 예외 상황에서만 사용해야함
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없도록 해야함

**[해당 문제를 일으키지 않을 방법]**
1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 `옵셔널` 이나 `특정값` 을 사용
2. 성능이 중요한 상황에서는 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 `옵셔널` 이나 `특정값` 을 선택
3. 다른 모든 경우엔 `상태 검사 메서드 방식` 이 조금 더 낫다고 할 수 있음. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기가 더 쉬움

<hr/>

## 아이템 70: 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

**[자바에서 문제 상황을 알리는 타입]**
1. 검사 예외

- `호출하는 쪽에서 복구하리라 여겨지는 상황` 이라면 검사 예외를 사용

[비검사 throwable]

- 프로그램에서 잡을 필요가 없거나 혹은 통상적으로 잡지 말아야 함
- 복구 불가능하거나 더 실행해봐야 득보다는 실이 많다는 뜻
- RuntimeException의 하위 클래스여야 함 (아니라면 사용하지 말자)

2. 런타임 예외

- 프로그래밍 오류
- 대부분 전제 조건을 만족하지 못했을 때 발생
- 전제 조건 위배란 단순히 클라이언트가 API의 명세에 기록된 계약을 지키지 못했다는 뜻

3. 에러

- 에외의 메서드는 주로 그 예외를 일으킨 상황에 관한 정보를 코드 형태로 전달하는 데 쓰임
- 이런 메서드가 없다면 프로그래머들은 오류 메시지를 파싱해 정보를 빼내야 하는 데, 대단히 나쁜 습관

- 검사 예외는 일반적으로 `복구할 수 있는 조건` 일 때 발생

<hr/>

## 아이템 71: 필요 없는 검사 예외 사용은 피하라
- 검사 예외 : 발생한 문제를 프로그래머가 처리하여 안정성을 높임
- 검사 예외를 과하게 사용하면 오히려 쓰기 불편한 API가 됨

```java
try{
	obj.action(args);
} catch (TheCheckedException e) {
	// 예외 상황 대처
}
```

- 상태 검사 메서드와 비검사 예외를 던지는 메서드로 리팩터링
```java
if (obj.actionPermitted(args)){
	obj.action(args);
} else {
	// 예외 상황 대처
}
```

<hr/>

## 아이템 72: 표준 예외를 사용하라
- 익숙한 규약을 따르기 때문에 쉬움
- 낯선 예외를 사용하지 않아서 읽기 쉬움
- 예외 클래스가 적을 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸림

**[자주 쓰이는 예외]**
1. IllegalArgumentException : 허용하지 않는 값이 인수로 건네졌을 때
2. IllegalStateException : 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때
3. NullPointerException : null 값을 허용하지 않는 메서드
4. IndexOutBoundsException : 어떤 시퀀스의 허용 범위를 넘는 값을 건낼 때
5. ConcurrentModificationException : 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때
6. UnsupportedOperationException : 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때

**[재사용하지 않으면 좋은 예외]**
- 이유 : 추상 클래스

1. Exception
2. RuntimeException
3. Throwable
4. Error

<hr/>

## 아이템 73: 추상화 수준에 맞는 예외를 던지라
- exception translation : 상위 계층에서는 저수준 예외를 잡아 `자신의 추상화 수준에 맞는 예외로 바꿔 던져야 함`
- 예외를 번역할 때 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄 (exception chaining)을 사용하는 것이 좋음

```java
try{
	// 저수준의 추상화를 이용한다
} catch (LowerLevelException cause){
	// 저수준의 예외를 고수준 예외에 실어 보낸다
	throw new HigherLevelException(cause);
}

class HigherLevelException extends Exception {
	HigherLevelException(Throwable cause){
		super(cause);
	}
}
```

- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만 그렇다고 남용해서는 곤란하다

<hr/>

## 아이템 74: 메서드가 던지는 모든 예외를 문서화하라
- 검사 예외는 따로 따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화
- 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법

<hr/>

## 아이템 75: 예외의 상세 메시지에 실패 관련 정보를 담으라
- 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 스택 추적 정보 (Stack Trace) 를 자동으로 출력
- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 함
- 최종 사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면, 예외메시지는 가동성보다는 담긴 내용이 더 중요

<hr/>

## 아이템 76: 가능한 한 실패 원자적으로 만들라
- 실패 원자적 (failure-atomic) : 일반화해 이야기하면, 호출된 메서드가 실패하더라도 해당 객체는 `메서드 호출 전 상태를 유지` 해야 함

**[실패 원자성을 유지하는 방법]**
1. 불변 객체 설계
- 실패하면 새로운 객체가 만들어지지는 않을 수 있으나, 기존 객체가 불안정한 상태에 빠지는 일은 결코 없음
- 불변 객체의 상태는 생성 시점에 고정되어 절대 변하지 않음

2. 작업 실행 전 매개변수의 유효성을 검사
- 객체 내부 상태를 변경하기 전에 잠재적 예외 가능성 대부분을 걸러낼 수 있는 방법
```java
public Object pop(){
	if (size == 0) throw new EmptyStackException();
	Object result = elements[--size];
	elements[size] = null; // 다 쓴 참조 해제
	return result;
}
```

3. 객체의 임시 복사본에서 작업을 수행한 다음 작업이 성공적으로 완료되면 원래 객체와 교환
- 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 사용

4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌리는 방법
- 디스크 기반의 내구성을 보장해야 한ㄴ 자료구조에 쓰임 (자주 쓰이지는 않음)

<hr/>

## 아이템 77: 예외를 무시하지 말라
- catch 블록을 비워두면 예외가 존재할 이유가 없어짐
- 예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignore로 바꿔놓자

- 
