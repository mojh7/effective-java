## 아이템 78: 공유 중인 가변 데이터는 동기화해 사용하라
- synchronized 키워드 : 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장

### [동기화의 중요성]
1. 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화
2. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못함

<br/>

- 언어 명세상 long, double 외의 변수를 읽고 쓰는 동작은 `원자적`

+) 원자적 : 여러 스레드가 같은 변수를 `동기화 없이 수정하는 중이`라도 항상 어떤 스레드가 정`상적으로 저장한 값을 온전히 읽어옴`

<br/>

3. 동기화는 배타적 실행 뿐 아니라 스레드 사이의 안정적 통신에서도 필요

<br/>

- `volatile` 로 선언하면 동기화를 생략해도 됨 : 배타적 수행과는 상관 없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장

<br/>

**[++ 증가 연산자]**
- 코드 상으로는 하나지만 실제로는 2개
- 1. 값을 읽고 2. 새로운 값을 저장
- 두번 째 스레드가 이 둘 사이를 비집고 들어와 읽어가면 첫 번째 스레드와 똑같은 값을 돌려받게 됨 
- safety failure 

<br/>

- `AtomicLong` : 락 없이도 (lock-free) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨 있음

<br/>

- 가장 좋은 방법 : `불변 데이터만 공유하거나 아무것도 공유하지 않는 것`

<br/>

- 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 대는 해당 객체에서 공유하는 부분만 동기화해도 됨
- `사실상 불변 (effectively immutable)` : 객체를 다시 수정할 일이 생기기 전까지 다른 스레드들은 동기화 없이 자유롭게 값을 읽어갈 수 있음
- `안전 발행 (safe publication)` : 다른 스레드에 이런 객체를 건네는 행위

<hr/>

## 아이템 79: 과도한 동기화는 피하라
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 `절대로 클라이언트에 양도하면 안됨`

**[외계인 메서드 (alien method)]**
- 동기화된 영역 안에서는 재정의할 수 있는 메서드를 호출하면 안됨
- 클라이언트가 넘겨준 함수 객체를 호출해서도 안됨
- 동기화된 영역은 예외를 일으키거나, 교착 상태에 빠지거나, 데이터를 훼손할 수 있음

<br/>

- 기본 규칙은 `동기화 영역에서는 가능한 한 일을 적게 하는 것`

<br/>

**[성능 문제]**
- 동기화가 초래하는 진짜 비용은 락을 얻는 데 사용하는 CPU 비용이 아님
- 바로 `경쟁하느라 낭비한 시간` : 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연 시간

<br/>

**[가변 클래스 작성 시 선택지]**
1. 동기화를 하지 않음 : 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 함
2. 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자

<hr/>

## 아이템 80: 스레드보다는 실행자, 테스크, 스트림을 애용하라
**[newCachedThreadPool]**
- 작은 프로그램이나 가벼운 서버
- 무거운 서버에는 좋지 않음
	- 요청받은 테스크들이 큐에 쌓이지 않고 즉시 스레드에 위임
	- 서버가 무겁다면 CPU 이용률이 100%로 치닫고 새로운 테스크가 도착하는 족족 또 다른 스레드를 생성하며 상황을 더욱 악화시킴
- 프로덕션에서는 쓰레드 수를 고정한 newFixedThreadPool, ThreadPolExecutor를 직접 사용 하는 편이 나음

<br/>

**[테스크]**
1. Runnable
2. Callable : 값을 반환하고 임의의 예외를 던질 수 있음

<br/>

- 테스크를 수행하는 일반적인 매커니즘 : 실행자 서비스
- 테스크 수행을 실행자 서비스에 맡기면 원하는 테스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경 가능

<hr/>

## 아이템 91: wait와 notify 보다는 동시성 유틸리티를 애용하라
- wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자

### [고수준 유틸리티]
1. 실행자 프레임워크
2. 동시성 컬렉션 (concurrent collection)
3. 동기화 장치 (synchronizer)

<br/>

**[동시성 컬렌션]**
- List, Queue, Map 같은 `표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션`
- 높은 동시성에 도달하기 위해 `동기화를 각자 내부에서 수행`
- 외부에서 락을 추가로 사용하면 오히려 속도가 느려짐
- 동시성 컬렉션에서 동시성을 무력화 하는 것은 불가능
- 동시성을 무력화하지 못하므로 `여러 메서드를 원자적으로 묶어 호출하는 일 역시 불가능`
- 여러 기본 동작을 하나의 원자적 동작으로 묶는 `상태 의존적 수정 메서드` 들이 추가

<br/>

- `Collections.synchronizedMap` 보다는 `ConcurrentHashMap` 을 사용하는 것이 훨씬 좋음
- 동기화된 맵을 동시성 맵으로 교체하는 것만으로도 동시성 애플리케이션의 성능은 극적으로 개선
- `ConcurrentHashMap` : 읽기 작업에는 여러 쓰레드가 동시에 읽을 수 있지만, 쓰기 작업에는 특정 세그먼트 or 버킷에 대한 Lock을 사용한다는 것

<br/>

- 시간 간격 : `System.currentTimeMillis` 가 아닌 `System.nanoTime` 을 사용

+) System.nanoTime : 더 정확하고 정밀. 시스템의 실시간 시계의 시간 보정에 영향을 받지 않음

<br/>

- wait 메서드를 사용할 때는 반드시 대기 반복문 (wait loop) 관용구를 사용하라
- 반복문 밖에서는 절대로 호출하지 말자

<br/>

### [조건이 만족되도 스레드가 깨어날 수 있는 상황]
- 스레드가 notify를 호출한 다음 대기중이던 스레드가 깨어나는 사이에 다른 스레드가 락을 얻어 그 락이 보호하는 상태를 변경
- 조건이 만족되지 않았음에도 다른 스레드가 실수로 혹은 악의적으로 notify를 호출
- 깨우는 스레드는 지나치게 관대헤서 대기 중인 스레드 중 일부만 조건이 충족되어도 notifyAll을 호출해 모든 스레드를 깨울 수 있음
- 허위 각성 (spurious wakeup) : 대기 중인 스레드가 notify 없이도 깨어나는 경우가 있음

<br/>

**[이상의 전제 조건들이 만족될지라도 notify 대신 `notifyAll` 을 사용하자]**
- 실수록 혹은 악의적으로 notify를 호출해야 하는 상황에 대비하기 위해 wait를 반복문 안에서 호출했듯
- notify 대신 notifyAll을 사용하면 관련 없는 `스레드가 실수로 혹은 악의적으로 wait를 호출하는 공격으로부터 보호`할 수 있음

<hr/>

## 아이템 82: 스레드 안전성 수준을 문서화하라
- 메서드 선언에 `synchronized 한정자를 선언` 할지는 `구현 이슈` 일 뿐 API에 속하지 않음
- 멀티 스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확하게 명시해야 함

<br/>

1. `불변 (immutable)` : 상수와 같아서 외부 동기화가 필요 없음 (ex) String, Long, BigInteger)
2. `무조건적 스레드 안전 (unconditionally thread-safe)` : 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전 (ex) AtomicLong, ConcurrentHashMap)
3. `조건부 스레드 안전 (conditionally thread-safe)` : 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요
4. `스레드 안전하지 않음 (not thread-safe)` : 인스턴스가 수정될 수 있음. 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 함 (ex) ArrayList, HashMap)
5. `스레드 적대적 (thread-hostile)` : 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서는 안전하지 않음

<br/>

```java
private final Object lock = new Object();

public void foo(){
	synchronized(lock){
		...
	}
}
```
- `서비스 거부 공격 (denial-of-service attack)` : 공개된 락을 오래 쥐고 놓지 않는 서비스 공격
- 락 필드는 final로 설정하라

